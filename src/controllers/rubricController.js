/**
 * Controlador de R√∫bricas
 */
import Rubric, { RUBRIC_TYPES } from '../models/Rubric.js';
import Commission from '../models/Commission.js';
import Course from '../models/Course.js';
import { generateRubricFromPDF } from '../services/n8nService.js';
import fs from 'fs/promises';
import path from 'path';

/**
 * Listar todas las r√∫bricas activas - GET /api/rubrics
 * @route GET /api/rubrics?commission_id=...&course_id=...&rubric_type=...&year=...&career_id=...&faculty_id=...&university_id=...
 * @access Public
 */
export const getRubrics = async (req, res) => {
  try {
    const { commission_id, course_id, rubric_type, year, career_id, faculty_id, university_id } = req.query;

    const filters = {};
    if (commission_id) filters.commission_id = commission_id;
    if (course_id) filters.course_id = course_id;
    if (rubric_type) filters.rubric_type = rubric_type;
    if (year) filters.year = parseInt(year);
    if (career_id) filters.career_id = career_id;
    if (faculty_id) filters.faculty_id = faculty_id;
    if (university_id) filters.university_id = university_id;

    const rubrics = await Rubric.findActive(filters);

    res.status(200).json({
      success: true,
      count: rubrics.length,
      data: rubrics,
    });
  } catch (error) {
    console.error('Error al obtener r√∫bricas:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener r√∫bricas',
      error: error.message,
    });
  }
};

/**
 * Obtener una r√∫brica por ID - GET /api/rubrics/:id
 * @route GET /api/rubrics/:id
 * @access Public
 */
export const getRubricById = async (req, res) => {
  try {
    const { id } = req.params;

    const rubric = await Rubric.findById(id);

    if (!rubric) {
      return res.status(404).json({
        success: false,
        message: 'R√∫brica no encontrada',
      });
    }

    res.status(200).json({
      success: true,
      data: rubric,
    });
  } catch (error) {
    console.error('Error al obtener r√∫brica:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener r√∫brica',
      error: error.message,
    });
  }
};

/**
 * Crear r√∫brica desde JSON - POST /api/rubrics
 * @route POST /api/rubrics
 * @access Private (solo admin)
 */
export const createRubric = async (req, res) => {
  try {
    const {
      name,
      commission_id,
      course_id,
      career_id,
      faculty_id,
      university_id,
      rubric_type,
      rubric_number,
      year,
      rubric_json,
    } = req.body;

    // Validar datos requeridos
    if (
      !name ||
      !commission_id ||
      !course_id ||
      !career_id ||
      !faculty_id ||
      !university_id ||
      !rubric_type ||
      !rubric_number ||
      !year ||
      !rubric_json
    ) {
      return res.status(400).json({
        success: false,
        message:
          'Faltan campos requeridos: name, commission_id, course_id, career_id, faculty_id, university_id, rubric_type, rubric_number, year, rubric_json',
      });
    }

    // Validar que rubric_type es v√°lido
    if (!Object.values(RUBRIC_TYPES).includes(rubric_type)) {
      return res.status(400).json({
        success: false,
        message: `rubric_type debe ser uno de: ${Object.values(RUBRIC_TYPES).join(', ')}`,
      });
    }

    // Verificar que la comisi√≥n existe
    const commission = await Commission.findOne({ commission_id, deleted: false });
    if (!commission) {
      return res.status(400).json({
        success: false,
        message: 'La comisi√≥n especificada no existe',
      });
    }

    // Verificar que el curso existe
    const course = await Course.findOne({ course_id, deleted: false });
    if (!course) {
      return res.status(400).json({
        success: false,
        message: 'El curso especificado no existe',
      });
    }

    // Verificar si ya existe una r√∫brica con ese tipo y n√∫mero en esa comisi√≥n
    const existingRubric = await Rubric.findOne({
      commission_id,
      rubric_type,
      rubric_number,
      deleted: false,
    });

    if (existingRubric) {
      return res.status(409).json({
        success: false,
        message: `Ya existe una r√∫brica de tipo ${rubric_type} con n√∫mero ${rubric_number} en esta comisi√≥n`,
      });
    }

    // Generar ID √∫nico
    const rubric_id = Rubric.generateRubricId(commission_id, rubric_type, rubric_number);

    // Crear r√∫brica
    const rubric = new Rubric({
      rubric_id,
      name,
      commission_id,
      course_id,
      career_id,
      faculty_id,
      university_id,
      rubric_type,
      rubric_number,
      year,
      rubric_json,
      source: 'json',
    });

    await rubric.save();

    res.status(201).json({
      success: true,
      message: 'R√∫brica creada exitosamente',
      data: rubric,
    });
  } catch (error) {
    console.error('Error al crear r√∫brica:', error);

    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map((err) => err.message);
      return res.status(400).json({
        success: false,
        message: 'Error de validaci√≥n',
        errors: messages,
      });
    }

    if (error.code === 11000) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe una r√∫brica con esa combinaci√≥n de comisi√≥n, tipo y n√∫mero',
        error: 'Clave duplicada',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al crear r√∫brica',
      error: error.message,
    });
  }
};

/**
 * Crear r√∫brica desde PDF - POST /api/rubrics/from-pdf
 * @route POST /api/rubrics/from-pdf
 * @access Private (solo admin)
 */
export const createRubricFromPDF = async (req, res) => {
  let pdfPath = null;

  try {
    // req.file es a√±adido por multer
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ archivo PDF',
      });
    }

    const {
      name,
      commission_id,
      course_id,
      career_id,
      faculty_id,
      university_id,
      rubric_type,
      rubric_number,
      year,
    } = req.body;

    // Validar datos requeridos
    if (
      !name ||
      !commission_id ||
      !course_id ||
      !career_id ||
      !faculty_id ||
      !university_id ||
      !rubric_type ||
      !rubric_number ||
      !year
    ) {
      return res.status(400).json({
        success: false,
        message:
          'Faltan campos requeridos: name, commission_id, course_id, career_id, faculty_id, university_id, rubric_type, rubric_number, year',
      });
    }

    // Validar que rubric_type es v√°lido
    if (!Object.values(RUBRIC_TYPES).includes(rubric_type)) {
      return res.status(400).json({
        success: false,
        message: `rubric_type debe ser uno de: ${Object.values(RUBRIC_TYPES).join(', ')}`,
      });
    }

    // Verificar que la comisi√≥n existe
    const commission = await Commission.findOne({ commission_id, deleted: false });
    if (!commission) {
      return res.status(400).json({
        success: false,
        message: 'La comisi√≥n especificada no existe',
      });
    }

    // Verificar que el curso existe
    const course = await Course.findOne({ course_id, deleted: false });
    if (!course) {
      return res.status(400).json({
        success: false,
        message: 'El curso especificado no existe',
      });
    }

    // Verificar si ya existe una r√∫brica con ese tipo y n√∫mero en esa comisi√≥n
    const existingRubric = await Rubric.findOne({
      commission_id,
      rubric_type,
      rubric_number,
      deleted: false,
    });

    if (existingRubric) {
      return res.status(409).json({
        success: false,
        message: `Ya existe una r√∫brica de tipo ${rubric_type} con n√∫mero ${rubric_number} en esta comisi√≥n`,
      });
    }

    pdfPath = req.file.path;

    // Obtener userId del usuario autenticado
    const userId = req.user?.id;

    // Llamar a n8n para generar r√∫brica (con API key del usuario)
    console.log('üìÑ Generando r√∫brica desde PDF con n8n...');
    const rubric_json = await generateRubricFromPDF(pdfPath, userId);

    // Generar ID √∫nico
    const rubric_id = Rubric.generateRubricId(commission_id, rubric_type, rubric_number);

    // Crear r√∫brica
    const rubric = new Rubric({
      rubric_id,
      name,
      commission_id,
      course_id,
      career_id,
      faculty_id,
      university_id,
      rubric_type,
      rubric_number,
      year,
      rubric_json,
      source: 'pdf',
      original_file_url: req.file.filename, // Guardamos el nombre del archivo
    });

    await rubric.save();

    res.status(201).json({
      success: true,
      message: 'R√∫brica creada exitosamente desde PDF',
      data: rubric,
    });
  } catch (error) {
    console.error('Error al crear r√∫brica desde PDF:', error);

    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map((err) => err.message);
      return res.status(400).json({
        success: false,
        message: 'Error de validaci√≥n',
        errors: messages,
      });
    }

    if (error.code === 11000) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe una r√∫brica con esa combinaci√≥n de comisi√≥n, tipo y n√∫mero',
        error: 'Clave duplicada',
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al crear r√∫brica desde PDF',
      error: error.message,
    });
  } finally {
    // Limpiar archivo temporal
    if (pdfPath) {
      try {
        await fs.unlink(pdfPath);
        console.log('‚úÖ Archivo temporal eliminado:', pdfPath);
      } catch (err) {
        console.error('‚ö†Ô∏è Error al eliminar archivo temporal:', err);
      }
    }
  }
};

/**
 * Actualizar r√∫brica - PUT /api/rubrics/:id
 * @route PUT /api/rubrics/:id
 * @access Private (solo admin)
 * @note No se permite cambiar commission_id, rubric_type ni rubric_number por integridad referencial
 */
export const updateRubric = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, rubric_json, course_id, career_id, faculty_id, university_id, year } = req.body;

    // Validar datos
    if (!name && !rubric_json && !course_id && !career_id && !faculty_id && !university_id && !year) {
      return res.status(400).json({
        success: false,
        message: 'Al menos un campo es requerido para actualizar',
      });
    }

    // Buscar r√∫brica
    const rubric = await Rubric.findById(id);

    if (!rubric) {
      return res.status(404).json({
        success: false,
        message: 'R√∫brica no encontrada',
      });
    }

    // Actualizar campos
    if (name) rubric.name = name;
    if (rubric_json) rubric.rubric_json = rubric_json;
    if (course_id) rubric.course_id = course_id;
    if (career_id) rubric.career_id = career_id;
    if (faculty_id) rubric.faculty_id = faculty_id;
    if (university_id) rubric.university_id = university_id;
    if (year) rubric.year = year;

    await rubric.save();

    res.status(200).json({
      success: true,
      message: 'R√∫brica actualizada exitosamente',
      data: rubric,
    });
  } catch (error) {
    console.error('Error al actualizar r√∫brica:', error);

    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map((err) => err.message);
      return res.status(400).json({
        success: false,
        message: 'Error de validaci√≥n',
        errors: messages,
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error al actualizar r√∫brica',
      error: error.message,
    });
  }
};

/**
 * Eliminar r√∫brica (baja l√≥gica) - DELETE /api/rubrics/:id
 * @route DELETE /api/rubrics/:id
 * @access Private (solo admin)
 */
export const deleteRubric = async (req, res) => {
  try {
    const { id } = req.params;

    const rubric = await Rubric.findById(id);

    if (!rubric) {
      return res.status(404).json({
        success: false,
        message: 'R√∫brica no encontrada',
      });
    }

    await rubric.softDelete();

    res.status(200).json({
      success: true,
      message: 'R√∫brica eliminada exitosamente',
    });
  } catch (error) {
    console.error('Error al eliminar r√∫brica:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar r√∫brica',
      error: error.message,
    });
  }
};
